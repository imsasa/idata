{"version":3,"file":"main.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA","sources":["webpack://ivalid/webpack/universalModuleDefinition","webpack://ivalid/./assets/evt.js","webpack://ivalid/./assets/object.js","webpack://ivalid/./assets/throttle.js","webpack://ivalid/./src/field.js","webpack://ivalid/./src/model.js","webpack://ivalid/webpack/bootstrap","webpack://ivalid/webpack/runtime/define property getters","webpack://ivalid/webpack/runtime/hasOwnProperty shorthand","webpack://ivalid/webpack/runtime/make namespace object","webpack://ivalid/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","\n/**\n * 创建一个订阅管理对象\n * @class Evt\n * @constructor\n */\nfunction Evt(ctx) {\n    if(ctx){\n        let evt   = this;\n        ctx.$on   = (name, fn) => evt.subscribe(name, fn);\n        ctx.$un   = (name, fn) => evt.remove(name, fn);\n        ctx.$emit = (...arg) => evt.trigger(...arg);\n    }\n}\n\nEvt.prototype             = {\n    /**\n     * 订阅\n     * @param  {string} key 订阅名称\n     * @param  {function} fn 触发的方法\n     * @returns {Evt}\n     */\n    subscribe: function (key, fn) {\n        this[key] || (this[key] = []);\n        this[key].push(fn);\n        return this;\n    },\n    /**\n     * 触发\n     * @params {string} 订阅名称\n     * @args {*...} 触发事件需传递的参数\n     * @returns {Evt}\n     */\n    trigger: function (key, ...args) {\n        let len, fns;\n        fns = this[key];\n        for (len = fns ? fns.length : 0; len--;) {\n            fns[len].apply(undefined, args);\n        }\n        return this;\n    },\n    /**\n     * 移除某个订阅\n     * @param key\n     * @param fn\n     * @returns {Evt}\n     */\n    remove: function (key, fn) {\n        let fns = this[key], len;\n        if (!fns || !fn) {\n            !fn && (fns = []);\n            return this;\n        }\n        for (len = fns.length; len--;) {\n            fn === fns[len] && fns.splice(i = len, 1);\n        }\n        return this;\n    }\n};\nEvt.prototype.constructor = Evt;\nexport default Evt;\n\n","/**\n * object 对象相关操作\n * @module Object\n */\n\n// /**\n//  * 将sourceObj中的属性拷贝到destObj中，如果destObj中属性存在则不拷贝\n//  * @param destObj\n//  * @param sourceObj\n//  * @return {Object}\n//  */\n// export function copyIfNotExist(destObj, sourceObj) {\n//     let idx;\n//     destObj || (destObj = {});\n//     for (idx in sourceObj) {\n//         destObj[idx] === undefined && (destObj[idx] = sourceObj[idx])\n//     }\n//     return destObj;\n// };\n\n\nexport function has(obj, flag) {\n    for (let i in obj) {\n        if (flag === obj[i]) return true;\n    }\n    return false;\n}\n\n/**\n *\n * @param obj\n * @param flag\n * @return {boolean}\n */\nexport function notAll(obj, flag,prop) {\n    for (let i in obj) {\n        let tmp=obj[i];\n        if (flag !== tmp) return true;\n    }\n    return false;\n}","/**\n *\n * @param fn\n * @param delay\n * @param opt\n * @param mode\n * @returns {retFn}\n * @private\n */\nfunction _throttle_(fn, delay = 1000, opt, mode) {\n    if (typeof delay === \"object\") {\n        opt   = delay;\n        delay = opt.delay || 1000;\n    }\n    let {immediate, leave, promise} = opt || {};\n    let timer, t                    = 0, p, pres, prej, args;\n\n    function _timer_(ctx, res, rej) {\n        if (!mode && timer) return;\n        mode && timer && clearTimeout(timer);\n        prej  = rej;\n        pres  = res;\n        timer = setTimeout(() => {\n            if (!timer) return;\n            promise ? pres(fn.apply(ctx, args)) : fn.apply(ctx, args);\n            timer = undefined;\n            pres  = prej = p = undefined;\n            t     = Date.now();\n        }, delay);\n    }\n\n    function retFn() {\n        if (!timer || !leave) args = arguments;\n        if (!timer && Date.now() - t > delay && immediate) {\n            t = Date.now();\n            return promise ? Promise.resolve(fn.apply(this, args)) : fn.apply(this, args);\n        }\n        (!p && promise) ? p = new Promise((res, rej) => _timer_(this, res, rej))\n            : _timer_(this, pres, prej);\n        return p;\n    }\n\n    retFn.clear = () => {\n        clearTimeout(timer) || (timer = undefined);\n        pres = p = undefined;\n        prej && prej(\"$rej$\");\n        prej = undefined;\n        t    = 0;\n        return retFn;\n    };\n    return retFn;\n}\n\n/**\n *\n * @param fn\n * @param {number} [delay=1000]\n * @param {object} [opt]\n * @returns {Function}\n */\nexport function throttle(fn, delay, opt) {\n    return _throttle_(fn, delay, opt, 0)\n}\n\n/**\n *\n * @param fn\n * @param {number} [delay=1000]\n * @param {object} [opt]\n * @returns {Function}\n */\nexport function debounce(fn, delay, opt) {\n    return _throttle_(fn, delay, opt, 1);\n}\n\n // default {throttle, debounce}","import {throttle} from \"../assets/throttle.js\";\n\n// import Evt from \"../assets/evt.js\"\nfunction isDiff(a1, a2) {\n    if (!Array.isArray(a1)) return a1 !== a2;\n    if ((a1 && !a2) || (!a1 && a2) || a1.length !== a2.length) return true;\n    for (let i = 0, n = a1.length; i < n; i++)\n        if (!a2.includes(a1[i])) return true;\n    return false;\n}\n\nfunction proxyArray(initVal = [], fn) {\n    let arr              = [...initVal];\n    let myArrayPrototype = Object.create(Array.prototype);\n    [\n        \"push\", \"pop\", \"shift\", \"unshift\", \"splice\", \"sort\", \"reverse\"\n    ].forEach(method => {\n        let m                    = Array.prototype[method];\n        myArrayPrototype[method] = function () {\n            let pre    = [...this];\n            let result = m.apply(this, arguments);\n            fn(this, pre);\n            return result;\n        };\n    });\n    arr.__proto__ = myArrayPrototype;\n    return arr;\n}\n\nfunction ifDirtyFn(newValue, initValue, preValue) {\n    this.$ref && this.$ref.$emit(\"fieldValueChg\", this.name, newValue, preValue);\n    if (this.isModified !== isDiff(newValue, initValue)) {\n        this.isModified = !this.isModified;\n        this.$ref && this.$ref.$emit(\"fieldModChg\", this.name, this.isModified);\n        //this.$emit('isModifiedChange', this.isModified,this);\n    }\n    this.$validate();\n}\n\nlet computeFn;\nlet willComputed = (function () {\n    let set       = new Set();\n    let executeFn = function () {\n        set.forEach(i => {\n            set.delete(i);\n            i()\n        });\n    }\n    return {\n        add(v) {\n            set.add(v);\n            executeFn();\n        }\n    }\n})();\n\n/**\n *\n * @param initVal\n * @param ctx\n * @constructor\n */\n\nfunction Destor(initVal, ctx) {\n    let value;\n    let fn = (newVal, preVal) => ifDirtyFn.call(ctx, newVal, initVal, preVal)\n\n    function setVal(newValue, preVal) {\n        if (!isDiff(newValue, preVal)) return;\n        Array.isArray(newValue) && (newValue = proxyArray(newValue, fn));\n        value = newValue;\n        fn(value = newValue, preVal);\n    }\n\n    if (ctx.type === 'compute') {\n        this.get  = () => value;\n        let cfn   = ctx.value;\n        computeFn = () => {\n            let newVal = Reflect.apply(cfn, ctx.$ref, []);\n            setVal(newVal, value);\n        }\n        initVal   = Reflect.apply(cfn, ctx.$ref, []);\n        computeFn = undefined;\n    } else {\n        let computeSet;\n        this.get = () => {\n            if (computeFn) {\n                computeSet || (computeSet = new Set());\n                computeSet.add(computeFn);\n            }\n            return value;\n        }\n        this.set = function (newVal) {\n            setVal(newVal, value);\n            if (!computeSet) return;\n            for (let i of computeSet) {\n                willComputed.add(i);\n            }\n        }\n    }\n    value = (initVal && Array.isArray(initVal)) ? proxyArray(initVal, fn) : initVal;\n}\n\n/**\n *\n * @param isValid\n * @returns {*}\n * @private\n */\nfunction FieldPrototype({name, alias, desc, validator, defaultValue, required, type, value}) {\n    this.name         = name || this.constructor.name;\n    this.alias        = alias;\n    this.desc         = desc;\n    this.validator    = validator;\n    this.defaultValue = defaultValue;\n    this.required     = !!required;\n    this.type         = type || '';\n    this.value        = value;\n    return this;\n}\n\n/**\n *\n */\nFieldPrototype.prototype.isField = true;\nconst validateHelper               = function (isValid) {\n    let validateMsg = isValid&&isValid.msg;\n    isValid         =  typeof isValid!=='boolean'?isValid.isValid:isValid;\n    if (this.isValid !== isValid) {\n        this.isValid     = isValid;\n        this.validateMsg = validateMsg;\n        this.$ref && this.$ref.$emit(\"fieldValidChg\", this.name, isValid,validateMsg);\n        // this.$emit('$isValidChange', this.isValid, this);\n    }\n    return isValid;\n}\nFieldPrototype.prototype.$validate = function () {\n    let isValid, val = this.value;\n    let validator    = this.validator;\n    if (this.required && val === undefined) {\n        isValid = false\n    } else if (val === this.defaultValue || (Array.isArray(val) && !isDiff(val, this.defaultValue))) {\n        isValid = true;\n    } else if (val === undefined || val === \"\") {\n        isValid = !this.required;\n    } else {\n        isValid = typeof validator === \"function\" ? this.validator(val) : (validator && this.validator.test(val));\n    }\n    isValid = (isValid && isValid.then) ? isValid : Promise.resolve(isValid);\n    isValid.then(i => Reflect.apply(validateHelper, this, [i]))\n    return isValid;\n};\nexport default function defineField(conf) {\n    function F(value, ref) {\n        if (value === undefined && this.required) {\n            value = this.defaultValue;\n        }\n        this.isValid    = undefined;\n        this.isModified = false;\n        this.$ref       = ref;\n        this.$validate  = throttle(this.$validate, 200, {immediate: false, promise: true});\n        Object.defineProperty(this, \"value\", new Destor(value, this));\n    }\n\n    F.prototype             = new FieldPrototype(conf);\n    F.prototype.constructor = F;\n    Object.defineProperty(F, \"name\", {value: conf.name});\n    F.isField = true;\n    return F;\n};\n","import defineField   from \"./field.js\";\nimport Evt           from \"../assets/evt.js\";\nimport {debounce}    from \"../assets/throttle.js\"\nimport {has} from \"../assets/object.js\"\n\n\nfunction ckValidationHelper(isValid, validation, ctx) {\n    if(isValid){\n        for (let i in validation) {\n            let tmp=validation[i].isValid;\n            if (!tmp) isValid= tmp;\n            if(isValid===false)break;\n        }\n    }\n    ctx.ref && (ctx.ref.$validation[ctx.name] = {isValid});\n    ctx.ref && ctx.ref.$emit('fieldValidChg', ctx.name, isValid);\n    ctx.$emit(\"$isValidChg\", isValid);\n    return ctx.$isValid = isValid;\n}\n\n/**\n *\n * @param fieldsCfg\n * @constructor\n */\nfunction ModelPrototype(fieldsCfg) {\n    let fields = [],computeFields=[];\n    for (let field of fieldsCfg) {\n        if (!field.isField && !field.$isModel) {\n            field = field.$isModel ? defineModel(field) : defineField(field)\n        }\n       field.type==='compute'?computeFields.push(field):fields.push(field);\n    }\n    this.$fields=fields;\n    return this;\n}\n\n/**\n *\n * @param validateAll undefined,false,true\n * @return {Promise<any[]>}\n */\nModelPrototype.prototype.$validate = function (validateAll) {\n    let ths       = this,\n        fieldData = ths.$fields,\n        varr      = [],\n        fields    = Object.keys(fieldData);\n    for (let fieldName of fields) {\n        let field = fieldData[fieldName];\n        let tmp   = field.$validate();\n        varr.push(tmp);\n    }\n    return Promise.allSettled(varr).then((ret) => ckValidationHelper(true, ths.$validation, this));\n};\n\nModelPrototype.prototype.$isModel = true;\n\nfunction fieldValidChgHandler(ctx) {\n    let _ = debounce(\n        function (isValid, validation) {\n            return ckValidationHelper(isValid, validation, ctx);\n        }, 80, {promise: true}\n    );\n    return function (fieldName, isValid,msg) {\n        ctx.$validation[fieldName].isValid = isValid;\n        ctx.$validation[fieldName].msg = msg;\n        if (isValid !== ctx.$isValid) _(isValid, ctx.$validation);\n        // if (isValid === true) {\n        //\n        // } else {\n        //     ctx.$ref && ctx.$ref.$emit(\"fieldValidChg\", ctx.constructor.name, false,ctx.$validation);\n        //     ctx.$emit(\"$isValidChg\", ctx.$isValid = false,ctx.validateMsg);\n        // }\n    }\n}\n\nfunction fieldModChgHandler(ctx) {\n    let _ = debounce(\n        function (modified, isMod) {\n            isMod = isMod || has(modified, true);\n            if (isMod === ctx.$isModified) return;\n            ctx.$isModified = isMod;\n            ctx.$ref && ctx.$ref.$emit(\"fieldModChg\", ctx.name, ctx.$isModified);\n            // ctx.$emit(\"modChg\", ctx.$isModified);\n            ctx.$emit('$isModifiedChg', ctx.$isModified);\n            return isMod;\n        }, 80, {promise: true, immediate: true}\n    );\n    return function (fieldName, isMod) {\n        ctx.$modified[fieldName] = isMod;\n        if (isMod === ctx.$isModified) return;\n        _(ctx.$modified, isMod);\n    }\n}\n\n/**\n *\n * @param cfg\n * @param watch\n * @return {M}\n * @constructor\n */\nexport default function defineModel(cfg,watch) {\n    let fields  = cfg.fields || cfg;\n    /**\n     *\n     * @param data\n     * @param isValid\n     * @private\n     */\n    watch||(watch=cfg.watch);\n    let _       = function (data) {\n        let flag         = data ? Array.isArray(data) : data = {},\n            modified     = {},\n            fields       = this.$fields;\n        this.$validation = {};\n        this.$isModified = false;\n        this.$fields     = {};\n        this.$isValid    = undefined;\n        new Evt(this);\n        for (let idx = 0, len = fields.length; idx < len; idx++) {\n            let field,\n                fieldCls            = fields[idx],\n                fname               = fieldCls.name,\n                initVal             = flag ? data[idx] : data[fname];\n            field                   = new fieldCls(initVal, this);\n            field.idx               = idx;\n            modified[fname]         = false;\n            this.$fields[fname]     = field;\n            this.$validation[fname] = field.$isModel ? field.$validation : {isValid:field.isValid,msg:field.validateMsg};\n            Object.defineProperty(this, fname, {\n                set         : function (value) {\n                    field.$isModel ? Object.assign(field, value) : field.value = value;\n                },\n                get         : () => field.value,\n                enumerable  : true,\n                configurable: true\n            });\n        }\n        this.$modified = modified;\n        this.$on(\"fieldValidChg\", fieldValidChgHandler(this));\n        this.$on(\"fieldModChg\"  , fieldModChgHandler(this)  );\n        this.$on(\"fieldValueChg\", (fname, value,preValue) => {\n            if(watch&&watch[fname]){\n                Reflect.apply(watch[fname],this,[value,preValue]);\n            }\n            // evt.trigger(fname, value);\n        });\n        this.$validate = debounce(this.$validate, 100, {immediate: true, promise: true});\n    };\n    _.prototype = new ModelPrototype(fields);\n    _.$fields   = _.prototype.$fields;\n    cfg.name && Object.defineProperty(_, \"name\", {value: cfg.name});\n    _.prototype.constructor = _;\n    return _;\n}\n\n// module.exports = defineModel;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import model from \"./model.js\";\nimport field from \"./field.js\";\nexport default model;\nexport  {field,model as defineModel}\n// export model from './model';\n"],"names":[],"sourceRoot":""}